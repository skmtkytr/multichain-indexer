#!/usr/bin/env ruby
# frozen_string_literal: true

$stdout.sync = true
$stderr.sync = true

require_relative '../config/environment'
require 'temporalio/worker'

puts "Starting Temporal worker (pid=#{Process.pid})..."
Rails.logger.info 'Starting Temporal worker...'

# Retry connection to Temporal server with backoff
client = nil
5.times do |i|
  client = TemporalClient.connection
  break
rescue StandardError => e
  wait = (i + 1) * 5
  Rails.logger.warn "Failed to connect to Temporal (attempt #{i + 1}/5): #{e.message}. Retrying in #{wait}s..."
  TemporalClient.reset!
  sleep wait
end

raise 'Could not connect to Temporal after 5 attempts' if client.nil?

base_queue = ENV.fetch('TEMPORAL_TASK_QUEUE', 'evm-indexer')

workflows = [
  Indexer::BlockPollerWorkflow,
  Indexer::BlockProcessorWorkflow,
  Indexer::UtxoBlockProcessorWorkflow,
  Indexer::SubstrateBlockProcessorWorkflow,
  Indexer::BatchProcessorWorkflow,
  Indexer::WebhookDispatcherWorkflow
]

activities = [
  Indexer::FetchBlockActivity,
  Indexer::ProcessBlockActivity,
  Indexer::BatchFetchActivity,
  Indexer::DecodeTransfersActivity,
  Indexer::FetchTracesActivity,
  Indexer::UtxoFetchBlockActivity,
  Indexer::SubstrateFetchBlockActivity,
  Indexer::WebhookDispatchActivity
]

# Build task queues: base queue (for webhook dispatcher) + per-chain queues
task_queues = [base_queue]
ChainConfig.enabled.find_each do |chain|
  task_queues << chain.task_queue
end
task_queues.uniq!

puts "Task queues: #{task_queues.join(', ')}"

# Run all workers concurrently in threads
threads = task_queues.map do |queue|
  Thread.new(queue) do |q|
    worker = Temporalio::Worker.new(
      client: client,
      task_queue: q,
      workflows: workflows,
      activities: activities
    )
    Rails.logger.info "Worker started on task queue: #{q}"
    worker.run(shutdown_signals: %w[SIGINT SIGTERM])
  rescue => e
    Rails.logger.error "Worker on #{q} crashed: #{e.class} #{e.message}"
    raise
  end
end

## ══════════════════════════════════════════════════════════════════════════════
## Watchdog thread: ensures workflows are running for all active cursors
## ══════════════════════════════════════════════════════════════════════════════
MAX_RESTART_ATTEMPTS = 3
WATCHDOG_INTERVAL = 60 # seconds

watchdog_thread = Thread.new do
  restart_counters = Hash.new(0) # chain_id -> consecutive failure count

  loop do
    sleep WATCHDOG_INTERVAL

    begin
      IndexerCursor.where(status: 'running').find_each do |cursor|
        workflow_id = "evm-indexer-chain-#{cursor.chain_id}"
        workflow_running = false

        begin
          handle = client.workflow_handle(workflow_id)
          desc = handle.describe
          # status 1 = RUNNING, 2 = CONTINUED_AS_NEW
          workflow_running = [1, 2].include?(desc.status)
        rescue StandardError
          workflow_running = false
        end

        if workflow_running
          restart_counters[cursor.chain_id] = 0
          next
        end

        # Workflow not running but cursor says running — attempt restart
        restart_counters[cursor.chain_id] += 1
        attempt = restart_counters[cursor.chain_id]

        if attempt > MAX_RESTART_ATTEMPTS
          Rails.logger.error("[Watchdog] Chain #{cursor.chain_id}: exceeded #{MAX_RESTART_ATTEMPTS} restart attempts, marking error")
          cursor.mark_error!("Watchdog: workflow disappeared, #{MAX_RESTART_ATTEMPTS} restart attempts failed")
          restart_counters.delete(cursor.chain_id)
          next
        end

        Rails.logger.warn("[Watchdog] Chain #{cursor.chain_id}: workflow not running, restarting (attempt #{attempt}/#{MAX_RESTART_ATTEMPTS})")

        begin
          chain_config = ChainConfig.cached_find(cursor.chain_id)
          next unless chain_config&.enabled?

          from_block = cursor.last_indexed_block.positive? ? cursor.last_indexed_block + 1 : 0

          client.start_workflow(
            Indexer::BlockPollerWorkflow,
            {
              'chain_id' => cursor.chain_id,
              'chain_type' => chain_config.chain_type,
              'start_block' => from_block,
              'poll_interval_seconds' => chain_config.poll_interval_seconds,
              'blocks_per_batch' => chain_config.blocks_per_batch,
              'catchup_parallel_batches' => chain_config.catchup_parallel_batches
            },
            id: workflow_id,
            task_queue: chain_config.task_queue
          )

          Rails.logger.info("[Watchdog] Chain #{cursor.chain_id}: workflow restarted successfully from block #{from_block}")
          restart_counters[cursor.chain_id] = 0
        rescue StandardError => e
          Rails.logger.error("[Watchdog] Chain #{cursor.chain_id}: restart failed: #{e.message}")
        end
      end
    rescue StandardError => e
      Rails.logger.error("[Watchdog] Error in watchdog loop: #{e.message}")
    end
  end
end

puts "#{threads.size} workers + watchdog running. Press Ctrl+C to stop."
threads.each(&:join)
