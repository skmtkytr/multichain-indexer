#!/usr/bin/env ruby
# frozen_string_literal: true

$stdout.sync = true
$stderr.sync = true

require_relative '../config/environment'
require 'temporalio/worker'

puts "Starting Temporal worker (pid=#{Process.pid})..."
Rails.logger.info 'Starting Temporal worker...'

# Retry connection to Temporal server with backoff
client = nil
5.times do |i|
  client = TemporalClient.connection
  break
rescue StandardError => e
  wait = (i + 1) * 5
  Rails.logger.warn "Failed to connect to Temporal (attempt #{i + 1}/5): #{e.message}. Retrying in #{wait}s..."
  TemporalClient.reset!
  sleep wait
end

raise 'Could not connect to Temporal after 5 attempts' if client.nil?

base_queue = ENV.fetch('TEMPORAL_TASK_QUEUE', 'evm-indexer')

workflows = [
  Indexer::BlockPollerWorkflow,
  Indexer::BlockProcessorWorkflow,
  Indexer::UtxoBlockProcessorWorkflow,
  Indexer::SubstrateBlockProcessorWorkflow,
  Indexer::WebhookDispatcherWorkflow
]

activities = [
  Indexer::FetchBlockActivity,
  Indexer::ProcessBlockActivity,
  Indexer::DecodeTransfersActivity,
  Indexer::FetchTracesActivity,
  Indexer::UtxoFetchBlockActivity,
  Indexer::SubstrateFetchBlockActivity,
  Indexer::WebhookDispatchActivity
]

# Build task queues: base queue (for webhook dispatcher) + per-chain queues
task_queues = [base_queue]
ChainConfig.enabled.find_each do |chain|
  task_queues << chain.task_queue
end
task_queues.uniq!

puts "Task queues: #{task_queues.join(', ')}"

# Run all workers concurrently in threads
threads = task_queues.map do |queue|
  Thread.new(queue) do |q|
    worker = Temporalio::Worker.new(
      client: client,
      task_queue: q,
      workflows: workflows,
      activities: activities
    )
    Rails.logger.info "Worker started on task queue: #{q}"
    worker.run(shutdown_signals: %w[SIGINT SIGTERM])
  rescue => e
    Rails.logger.error "Worker on #{q} crashed: #{e.class} #{e.message}"
    raise
  end
end

puts "#{threads.size} workers running. Press Ctrl+C to stop."
threads.each(&:join)
